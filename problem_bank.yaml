problems:
  - id: "two_sum"
    title: "Two Sum"
    concept: "Hash Map Lookup"
    description: "Find two numbers that add up to target"
    snippet: |
      def two_sum(nums, target):
          seen = {}
          for i, num in enumerate(nums):
              complement = target - num
              if complement in seen:
                  return [seen[complement], i]
              seen[num] = i
          return []
    tags:
      data_structure: "hashmap"
      pattern: "hash_map_lookup"
      complexity: "O(n)"
      difficulty: "easy"
    test_cases:
      - input: "nums=[2,7,11,15], target=9"
        expected: "[0,1]"
        edge_case: false
      - input: "nums=[3,3], target=6"
        expected: "[0,1]"
        edge_case: true
        description: "Duplicate values"
      - input: "nums=[3,2,4], target=6"
        expected: "[1,2]"
        edge_case: false
    common_bugs:
      - "Forgetting to store index in hashmap"
      - "Not handling duplicate values correctly"
    quiz_questions:
      - question: "What line is missing to store the current number and its index?"
        answer: "seen[num] = i"
        context: "After checking if complement exists"

  - id: "binary_search"
    title: "Binary Search"
    concept: "Mid Calculation & Bounds Update"
    description: "Find target in sorted array"
    snippet: |
      def binary_search(nums, target):
          left, right = 0, len(nums) - 1
          while left <= right:
              mid = (left + right) // 2
              if nums[mid] == target:
                  return mid
              elif nums[mid] < target:
                  left = mid + 1
              else:
                  right = mid - 1
          return -1
    tags:
      data_structure: "array"
      pattern: "binary_search"
      complexity: "O(log n)"
      difficulty: "easy"
    test_cases:
      - input: "nums=[1,2,3,4,5], target=3"
        expected: "2"
        edge_case: false
      - input: "nums=[1,2,3,4,5], target=6"
        expected: "-1"
        edge_case: true
        description: "Target not found"
      - input: "nums=[], target=1"
        expected: "-1"
        edge_case: true
        description: "Empty array"
    common_bugs:
      - "Using left < right instead of left <= right"
      - "Not updating mid correctly (infinite loop)"
      - "Off-by-one errors in bounds"
    quiz_questions:
      - question: "What condition should be used in the while loop?"
        answer: "left <= right"
        context: "To ensure we check all elements"

  - id: "dfs_traversal"
    title: "DFS Tree Traversal"
    concept: "Recursion vs Queue Loop"
    description: "Depth-first search using recursion"
    snippet: |
      def dfs(root):
          if not root:
              return
          result = []
          
          def traverse(node):
              if not node:
                  return
              result.append(node.val)
              traverse(node.left)
              traverse(node.right)
          
          traverse(root)
          return result
    tags:
      data_structure: "tree"
      pattern: "dfs_recursion"
      complexity: "O(n)"
      difficulty: "medium"
    test_cases:
      - input: "root=TreeNode(1, TreeNode(2), TreeNode(3))"
        expected: "[1,2,3]"
        edge_case: false
      - input: "root=None"
        expected: "[]"
        edge_case: true
        description: "Empty tree"
    common_bugs:
      - "Forgetting null checks"
      - "Not handling base case properly"
    quiz_questions:
      - question: "What's the missing base case check?"
        answer: "if not node: return"
        context: "At the start of traverse function"

  - id: "sliding_window"
    title: "Sliding Window Maximum"
    concept: "Add/Remove While Maintaining Condition"
    description: "Find max in each sliding window"
    snippet: |
      def max_sliding_window(nums, k):
          from collections import deque
          dq = deque()
          result = []
          
          for i in range(len(nums)):
              # Remove elements outside window
              while dq and dq[0] <= i - k:
                  dq.popleft()
              
              # Remove smaller elements
              while dq and nums[dq[-1]] < nums[i]:
                  dq.pop()
              
              dq.append(i)
              
              if i >= k - 1:
                  result.append(nums[dq[0]])
          
          return result
    tags:
      data_structure: "array, deque"
      pattern: "sliding_window"
      complexity: "O(n)"
      difficulty: "hard"
    test_cases:
      - input: "nums=[1,3,-1,-3,5,3,6,7], k=3"
        expected: "[3,3,5,5,6,7]"
        edge_case: false
      - input: "nums=[1], k=1"
        expected: "[1]"
        edge_case: true
        description: "Single element"
    common_bugs:
      - "Not removing elements outside window"
      - "Wrong condition for adding to result"
    quiz_questions:
      - question: "What condition determines when to add to result?"
        answer: "if i >= k - 1"
        context: "After adding current index to deque"
